## 按位与、或、异或等运算方法和常见使用场景<br>
计算机的世界只有1和0，这个冯诺依曼存储模型的计算机不知道什么时候才能改革列:)。在经常的编码中，也会使用到最细颗粒级别的二进制位运算。下面来总结总结，如何使用位bit运算。完全接近底层的bit运算，那速度当然是杠杠的。>_<....<br>
<br>
  * **按位与运算(&)**<br>
  参加运算的两个数据，按二进制进行"与"运算。运算规则：<br>
  如下表简而言之，0与任何数相与都得到0。`两位同时为1，结果才为1，否则为0`
  <table border="border">
    <tr>
      <th>0 & 0 = 0</th>
      <th>0 & 1 = 0</th>
      <th>1 & 0 = 0</th>
      <th>1 & 1 = 0</th>
    </tr>
  </table>
  eg: 3&5 即为:0000 0011 & 0000 0101 = 0000 0001,因此，3&5 = 1。 另外，负数按照补码形式参加运算<br>
**&运算使用场景:**<br>
    * 清零。如果想将一个单元清零，即使其二进制全为0，只要与一个各位都为0的数值相与，结果清零。<br>
    <br>
    * 取一个数对应二进制中指定位上的二进制数(0|1)<br>
    方法:找一个数，对应X要取的位,该数的对应为1，其余位清零，此数与X进行**位运算(&)**,就可以得到X中指定位。<br>
    eg: 设X=10101110 <br>
    取X的低四位，用X & 0000 1111 = 0000 1110即可截取到X的二进制后四位。还可以取X的2、4、6位等等<br>
    ```java
    @Test
    public void andTest(){
      int x = 120;
      //1111 0000
      System.out.println(Integer.toBinaryString(x));  //查看该整数的二进制  
      /*
      *  若是结果为0的，说明对应位数上的二进制数为0，若是为&右边数值原样数值则为1
      * eg  A&B = 0, B=2^n , 则A第n位为0; 若是A&B=1，则为1.
      */
      System.out.println(x&1);  //1th 查看第一位从右往左。
      System.out.println(x&2);  //2th 2=10
      System.out.println(x&4);  //3th 4=100
      System.out.println(x&8);  //4th 8=1000
      System.out.println(x&16);  //5th 16=10000
      System.out.println(x&32);   //6th >>100000
      }
      
      output:
      /*
       *    1111000
            0
            0
            0
            8
            16
            32
         */
    ```
  <br>
  * **按位或运算符(|)**<br>
  参加运算的两个对象，按二进制位进行“或”运算。<br>
  如下表简而言之，运算规则是:`参加运算的两个对象只要有一个为1，其值为1。`
  <table border="border">
    <tr>
      <th>0 & 0 = 0</th>
      <th>0 & 1 = 1</th>
      <th>1 & 0 = 1</th>
      <th>1 & 1 = 1</th>
    </tr>
  </table>
  eg:3|5　即 0000 0011 | 0000 0101 = 0000 0111 因此，3|5的值得7。<br>
  **使用场景:**
<br>
    * 常用来对一个数据的某些位置1<br>
    方法:找到一个数A，对应数X要置1二进制数，数X为对应位为1，其余位为零。数A与X相或，可以使得A指定位置上的0位变为1。<br>
    eg:将A=10100000的低4位置1 ，X=0000 1111,用 A | X = 1010 1111即可得到。<br>
```java
@Test
public void orTest(){
  int x = 120;
  int tmp = x | 4;  //x|100 即将x第三位设为1
  System.out.println(Integer.toBinaryString(x));
  System.out.println(Integer.toBinaryString(tmp));
  
  /*
  * output:
  * 1111 0000
  * 1111 1000
  */
  
  tmp = x|6;  //x|0110 第二三位上置1  注意X的值经过上面步骤已经改变
  System.out.println(Integer.toBinaryString(x));
  System.out.println(Integer.toBinaryString(tmp));
  
  /*
  * output:
  * 1111 1000
  * 1111 1110
  */
}
```
<br>
  * 异或运算(^)<br>
  参加运算的两个数据，按二进制位进行“异或”运算。运算规则:<br>
  即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。
  <table border="border">
    <tr>
      <th>0 & 0 = 0</th>
      <th>0 & 1 = 1</th>
      <th>1 & 0 = 1</th>
      <th>1 & 1 = 0</th>
    </tr>
  </table>  
<br>
**应用场景:**<br>
    * 使特定位翻转,找一个数A，x为要翻转的位为1，其余位为零的二进制数，此数A与X对应位异或即可。
    eg: A=1010 1110 ,要使得A低4位反转,X=0000 1111，用A^X=1010 0001即可得到。<br>
    **与0异或，保留原值**，A^0000 0000 = 1010 1110 <br>
<br>
  * **取反运算符(~)**<br>
  参加运算的一个数据，按二进制位进行“取反”运算。<br>
  运算规则：`~1=0； ~0=1`,即：对一个二进制数按位取反，即将0变1，1变0。<br>
  **使用场景:**要使得一个数的最低位为0，可以表示为:`A&~1`，~1的值1111111111111110,再按“与”运算，最低位一定为0。因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。<br>
<br>
  * **左移运算符(<<)**<br>
  将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。实则左移动几位就乘以2几次方。<br>
  eg: a = a << 2 将a的二进制位左移2位，右补0。所以a=a*4。**若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。**<br>
<br>
  * **(有符号)右移运算符(>>)**<br>
  将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br>
  操作数每右移一位，相当于该数除以2。 例如：a = a >> 2 将a的二进制位右移2位，a = a /2 。 左补0 or 补1 得看被移数是正还是负。<br>
```javascript
  运算符把 expression1 的所有位向右移 expression2 指定的位数。expression1 的符号位被用来填充右移后左边空出来的位。向右移出的位被丢弃。 
例如，下面的代码被求值后，temp 的值是 -4： 
-14 （即二进制的 11110010）右移两位等于 -4 （即二进制的 11111100）。 
var temp = -14 >> 2
```
<br>
  * **无符号右移运算符(>>>)**<br>
  运算符把 expression1 的各个位向右移 expression2 指定的位数。右移后左边空出的位用零来填充。移出右边的位被丢弃。<br> 
例如：var temp = -14 >>> 2 <br>
变量 temp 的值为 -14 （即二进制的 11111111 11111111 11111111 11110010），向右移两位后等于 1073741820 （即二进制的 00111111 11111111 11111111 11111100）。
    
